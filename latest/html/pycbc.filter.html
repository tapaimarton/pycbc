

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pycbc.filter package &mdash; PyCBC be65a5 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PyCBC be65a5 documentation" href="index.html"/>
        <link rel="up" title="pycbc package" href="pycbc.html"/>
        <link rel="next" title="pycbc.inference package" href="pycbc.inference.html"/>
        <link rel="prev" title="pycbc.fft package" href="pycbc.fft.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PyCBC
          

          
          </a>

          
            
            
              <div class="version">
                1.6.8
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="install.html">Installing PyCBC</a></li>
<li class="toctree-l1"><a class="reference internal" href="building_bundled_executables.html">Building Bundled Executables</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_psd_estimation_workflow.html"><code class="docutils literal"><span class="pre">pycbc_make_psd_estimation_workflow</span></code>: A workflow generator for noise estimation</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_coinc_search_workflow.html"><code class="docutils literal"><span class="pre">pycbc_make_coinc_search_workflow</span></code>: A workflow to search for gravitational waves</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow/pygrb.html"><code class="docutils literal"><span class="pre">pycbc_make_offline_grb_workflow</span></code>: A GRB triggered CBC analysis workflow generator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow/pycbc_make_inference_workflow.html"><code class="docutils literal"><span class="pre">pycbc_make_inference_workflow</span></code>: A parameter estimation workflow generator</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="tmpltbank.html">PyCBC template bank generation documentation (<code class="docutils literal"><span class="pre">pycbc.tmpltbank</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="inference.html">PyCBC inference documentation (<code class="docutils literal"><span class="pre">pycbc.inference</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="hwinj.html">Hardware injection waveform generation</a></li>
<li class="toctree-l1"><a class="reference internal" href="banksim.html">Calculating the Effectualness (Fitting Factor) of Template Banks</a></li>
<li class="toctree-l1"><a class="reference internal" href="faithsim.html">Dag Generator for Doing Faithfulness Comparisons</a></li>
<li class="toctree-l1"><a class="reference internal" href="upload_to_gracedb.html">Uploading triggers to gracedb</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="frame.html">Reading Gravitational-wave Frames</a></li>
<li class="toctree-l1"><a class="reference internal" href="psd.html">Handling PSDs</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise.html">Generating Noise</a></li>
<li class="toctree-l1"><a class="reference internal" href="waveform.html">Waveforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="filter.html">Filtering</a></li>
<li class="toctree-l1"><a class="reference internal" href="distributions.html">Using PyCBC Distributions from PyCBC Inference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documenting PyCBC code</a></li>
<li class="toctree-l1"><a class="reference internal" href="release.html">Creating Releases of PyCBC</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="formats/hdf_format.html">HDF files within the PyCBC workflow</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="workflow.html">Workflow: the inspiral analysis workflow generator (<code class="docutils literal"><span class="pre">pycbc.workflow</span></code>)</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">pycbc</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="pycbc.html">pycbc package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="pycbc.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="pycbc.events.html">pycbc.events package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.fft.html">pycbc.fft package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">pycbc.filter package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.inference.html">pycbc.inference package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.inject.html">pycbc.inject package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.io.html">pycbc.io package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.noise.html">pycbc.noise package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.psd.html">pycbc.psd package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.results.html">pycbc.results package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.tmpltbank.html">pycbc.tmpltbank package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.types.html">pycbc.types package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.vetoes.html">pycbc.vetoes package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.waveform.html">pycbc.waveform package</a></li>
<li class="toctree-l4"><a class="reference internal" href="pycbc.workflow.html">pycbc.workflow package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.bin_utils">pycbc.bin_utils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.conversions">pycbc.conversions module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.coordinates">pycbc.coordinates module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.cosmology">pycbc.cosmology module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.detector">pycbc.detector module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.frame">pycbc.frame module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.future">pycbc.future module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.gate">pycbc.gate module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.libutils">pycbc.libutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.opt">pycbc.opt module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.pnutils">pycbc.pnutils module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.pool">pycbc.pool module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.rate">pycbc.rate module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.scheme">pycbc.scheme module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.sensitivity">pycbc.sensitivity module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.strain">pycbc.strain module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.version">pycbc.version module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc.weave">pycbc.weave module</a></li>
<li class="toctree-l3"><a class="reference internal" href="pycbc.html#module-pycbc">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyCBC</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="modules.html">pycbc</a> &raquo;</li>
        
          <li><a href="pycbc.html">pycbc package</a> &raquo;</li>
        
      <li>pycbc.filter package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/pycbc.filter.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pycbc-filter-package">
<h1>pycbc.filter package<a class="headerlink" href="#pycbc-filter-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pycbc.filter.autocorrelation">
<span id="pycbc-filter-autocorrelation-module"></span><h2>pycbc.filter.autocorrelation module<a class="headerlink" href="#module-pycbc.filter.autocorrelation" title="Permalink to this headline">¶</a></h2>
<p>This modules provides functions for calculating the autocorrelation function
and length of a data series.</p>
<dl class="function">
<dt id="pycbc.filter.autocorrelation.calculate_acf">
<code class="descclassname">pycbc.filter.autocorrelation.</code><code class="descname">calculate_acf</code><span class="sig-paren">(</span><em>data</em>, <em>delta_t=1.0</em>, <em>unbiased=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/autocorrelation.html#calculate_acf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.autocorrelation.calculate_acf" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the one-sided autocorrelation function.</p>
<p>Calculates the autocorrelation function (ACF) and returns the one-sided
ACF. The ACF is defined as the autocovariance divided by the variance. The
ACF can be estimated using</p>
<img src="_images/mathmpl/math-326afa5650.png" class="center" /><p>Where <img src="_images/mathmpl/math-4f7f250690.png" style="position: relative; bottom: -8px"/> is the ACF, <img src="_images/mathmpl/math-338c8c6e10.png" style="position: relative; bottom: -6px"/> is the data series at
time t, <img src="_images/mathmpl/math-3488de1d0a.png" style="position: relative; bottom: -7px"/> is the mean of <img src="_images/mathmpl/math-338c8c6e10.png" style="position: relative; bottom: -6px"/>, and <img src="_images/mathmpl/math-bac0793fc4.png" style="position: relative; bottom: -2px"/> is
the variance of <img src="_images/mathmpl/math-338c8c6e10.png" style="position: relative; bottom: -6px"/>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : TimeSeries or numpy.array</p>
<blockquote>
<div><p>A TimeSeries or numpy.array of data.</p>
</div></blockquote>
<p><strong>delta_t</strong> : float</p>
<blockquote>
<div><p>The time step of the data series if it is not a TimeSeries instance.</p>
</div></blockquote>
<p><strong>unbiased</strong> : bool</p>
<blockquote>
<div><p>If True the normalization of the autocovariance function is n-k
instead of n. This is called the unbiased estimation of the
autocovariance. Note that this does not mean the ACF is unbiased.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>acf</strong> : numpy.array</p>
<blockquote class="last">
<div><p>If data is a TimeSeries then acf will be a TimeSeries of the
one-sided ACF. Else acf is a numpy.array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.autocorrelation.calculate_acl">
<code class="descclassname">pycbc.filter.autocorrelation.</code><code class="descname">calculate_acl</code><span class="sig-paren">(</span><em>data</em>, <em>m=5</em>, <em>k=2</em>, <em>dtype=&lt;type 'int'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/autocorrelation.html#calculate_acl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.autocorrelation.calculate_acl" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the autocorrelation length (ACL).</p>
<p>ACL is estimated using</p>
<blockquote>
<div>r = 1 + 2 sum_{i=1}^{m*s} hat{R}(i) &lt; s</div></blockquote>
<p>Where r is the ACL and hat{R}(i) is the ACF that has been normalized so
that hat{R}(0) is 1.0. And s is equal to i/m.</p>
<p>The parameter k sets the maximum samples to use in calculation of ACL. The
maximum number of samples will be the length of the ACL divided by k.</p>
<p>The parameter m controls the length of the window that is summed to
compute the ACL.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : {TimeSeries, numpy.array}</p>
<blockquote>
<div><p>A TimeSeries or numpy.array of data.</p>
</div></blockquote>
<p><strong>dtype</strong> : {int, float}</p>
<blockquote>
<div><p>The datatype of the output. If the dtype was set to int, then the
ceiling is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>acl</strong> : {int, float}</p>
<blockquote class="last">
<div><p>The length s which is longer than the ACL. If ACL can not be estimated
then returns numpy.inf.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.filter.matchedfilter">
<span id="pycbc-filter-matchedfilter-module"></span><h2>pycbc.filter.matchedfilter module<a class="headerlink" href="#module-pycbc.filter.matchedfilter" title="Permalink to this headline">¶</a></h2>
<p>This modules provides functions for matched filtering along with associated
utilities.</p>
<dl class="function">
<dt id="pycbc.filter.matchedfilter.match">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">match</code><span class="sig-paren">(</span><em>vec1</em>, <em>vec2</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em>, <em>v1_norm=None</em>, <em>v2_norm=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#match"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the match between the two TimeSeries or FrequencySeries.</p>
<p>Return the match between two waveforms. This is equivelant to the overlap
maximized over time and phase.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vec1</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>vec2</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>psd</strong> : Frequency Series</p>
<blockquote>
<div><p>A power spectral density to weight the overlap.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin the match.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop the match.</p>
</div></blockquote>
<p><strong>v1_norm</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The normalization of the first waveform. This is equivalent to its
sigmasq value. If None, it is internally calculated.</p>
</div></blockquote>
<p><strong>v2_norm</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The normalization of the second waveform. This is equivalent to its
sigmasq value. If None, it is internally calculated.</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>&#8212;&#8212;-</strong></p>
<p class="last"><strong>match: float</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.matched_filter">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">matched_filter</code><span class="sig-paren">(</span><em>template</em>, <em>data</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em>, <em>sigmasq=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#matched_filter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.matched_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex snr.</p>
<p>Return the complex snr, along with its associated normalization of the
template, matched filtered against the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>template</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The template waveform</p>
</div></blockquote>
<p><strong>data</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The strain data to be filtered.</p>
</div></blockquote>
<p><strong>psd</strong> : FrequencySeries</p>
<blockquote>
<div><p>The noise weighting of the filter.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin the filter calculation. If None, begin at the
first frequency after DC.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop the filter calculation. If None, continue to the
the nyquist frequency.</p>
</div></blockquote>
<p><strong>sigmasq</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The template normalization. If none, this value is calculated
internally.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote class="last">
<div><p>A time series containing the complex snr.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.sigmasq">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">sigmasq</code><span class="sig-paren">(</span><em>htilde</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#sigmasq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.sigmasq" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the loudness of the waveform. This is defined (see Duncan
Brown&#8217;s thesis) as the unnormalized matched-filter of the input waveform,
htilde, with itself. This quantity is usually referred to as (sigma)^2
and is then used to normalize matched-filters with the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>htilde</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>psd</strong> : {None, FrequencySeries}, optional</p>
<blockquote>
<div><p>The psd used to weight the accumulated power.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin considering waveform power.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop considering waveform power.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sigmasq: float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.sigma">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">sigma</code><span class="sig-paren">(</span><em>htilde</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#sigma"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sigma of the waveform. See sigmasq for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>htilde</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>psd</strong> : {None, FrequencySeries}, optional</p>
<blockquote>
<div><p>The psd used to weight the accumulated power.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin considering waveform power.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop considering waveform power.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sigmasq: float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.get_cutoff_indices">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">get_cutoff_indices</code><span class="sig-paren">(</span><em>flow</em>, <em>fhigh</em>, <em>df</em>, <em>N</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#get_cutoff_indices"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.get_cutoff_indices" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the indices of a frequency series at which to stop an overlap
calculation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>flow: float</strong></p>
<blockquote>
<div><p>The frequency (in Hz) of the lower index.</p>
</div></blockquote>
<p><strong>fhigh: float</strong></p>
<blockquote>
<div><p>The frequency (in Hz) of the upper index.</p>
</div></blockquote>
<p><strong>df: float</strong></p>
<blockquote>
<div><p>The frequency step (in Hz) of the frequency series.</p>
</div></blockquote>
<p><strong>N: int</strong></p>
<blockquote>
<div><p>The number of points in the <strong>time</strong> series. Can be odd
or even.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">kmin: int</p>
<p class="last">kmax: int</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.sigmasq_series">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">sigmasq_series</code><span class="sig-paren">(</span><em>htilde</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#sigmasq_series"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.sigmasq_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a cumulative sigmasq frequency series.</p>
<p>Return a frequency series containing the accumulated power in the input
up to that frequency.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>htilde</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector</p>
</div></blockquote>
<p><strong>psd</strong> : {None, FrequencySeries}, optional</p>
<blockquote>
<div><p>The psd used to weight the accumulated power.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin accumulating power. If None, start at the beginning
of the vector.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop considering accumulated power. If None, continue
until the end of the input vector.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Frequency Series: FrequencySeries</p>
<blockquote class="last">
<div><p>A frequency series containing the cumulative sigmasq.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.make_frequency_series">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">make_frequency_series</code><span class="sig-paren">(</span><em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#make_frequency_series"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.make_frequency_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a frequency series of the input vector.</p>
<p>If the input is a frequency series it is returned, else if the input
vector is a real time series it is fourier transformed and returned as a
frequency series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vector</strong> : TimeSeries or FrequencySeries</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Frequency Series: FrequencySeries</p>
<blockquote class="last">
<div><p>A frequency domain version of the input vector.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.overlap">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">overlap</code><span class="sig-paren">(</span><em>vec1</em>, <em>vec2</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em>, <em>normalized=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the overlap between the two TimeSeries or FrequencySeries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vec1</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>vec2</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>psd</strong> : Frequency Series</p>
<blockquote>
<div><p>A power spectral density to weight the overlap.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin the overlap.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop the overlap.</p>
</div></blockquote>
<p><strong>normalized</strong> : {True, boolean}, optional</p>
<blockquote>
<div><p>Set if the overlap is normalized. If true, it will range from 0 to 1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">overlap: float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.overlap_cplx">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">overlap_cplx</code><span class="sig-paren">(</span><em>vec1</em>, <em>vec2</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em>, <em>normalized=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#overlap_cplx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.overlap_cplx" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex overlap between the two TimeSeries or FrequencySeries.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>vec1</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>vec2</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The input vector containing a waveform.</p>
</div></blockquote>
<p><strong>psd</strong> : Frequency Series</p>
<blockquote>
<div><p>A power spectral density to weight the overlap.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin the overlap.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop the overlap.</p>
</div></blockquote>
<p><strong>normalized</strong> : {True, boolean}, optional</p>
<blockquote>
<div><p>Set if the overlap is normalized. If true, it will range from 0 to 1.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">overlap: complex</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.matched_filter_core">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">matched_filter_core</code><span class="sig-paren">(</span><em>template</em>, <em>data</em>, <em>psd=None</em>, <em>low_frequency_cutoff=None</em>, <em>high_frequency_cutoff=None</em>, <em>h_norm=None</em>, <em>out=None</em>, <em>corr_out=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#matched_filter_core"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.matched_filter_core" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex snr and normalization.</p>
<p>Return the complex snr, along with its associated normalization of the template,
matched filtered against the data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>template</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The template waveform</p>
</div></blockquote>
<p><strong>data</strong> : TimeSeries or FrequencySeries</p>
<blockquote>
<div><p>The strain data to be filtered.</p>
</div></blockquote>
<p><strong>psd</strong> : {FrequencySeries}, optional</p>
<blockquote>
<div><p>The noise weighting of the filter.</p>
</div></blockquote>
<p><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin the filter calculation. If None, begin at the
first frequency after DC.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop the filter calculation. If None, continue to the
the nyquist frequency.</p>
</div></blockquote>
<p><strong>h_norm</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The template normalization. If none, this value is calculated internally.</p>
</div></blockquote>
<p><strong>out</strong> : {None, Array}, optional</p>
<blockquote>
<div><p>An array to use as memory for snr storage. If None, memory is allocated
internally.</p>
</div></blockquote>
<p><strong>corr_out</strong> : {None, Array}, optional</p>
<blockquote>
<div><p>An array to use as memory for correlation storage. If None, memory is allocated
internally. If provided, management of the vector is handled externally by the
caller. No zero&#8217;ing is done internally.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote>
<div><p>A time series containing the complex snr.</p>
</div></blockquote>
<p>corrrelation: FrequencySeries</p>
<blockquote>
<div><p>A frequency series containing the correlation vector.</p>
</div></blockquote>
<p><strong>norm</strong> : float</p>
<blockquote class="last">
<div><p>The normalization of the complex snr.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.correlate">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">correlate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#correlate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.correlate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pycbc.filter.matchedfilter.MatchedFilterControl">
<em class="property">class </em><code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">MatchedFilterControl</code><span class="sig-paren">(</span><em>low_frequency_cutoff</em>, <em>high_frequency_cutoff</em>, <em>snr_threshold</em>, <em>tlen</em>, <em>delta_f</em>, <em>dtype</em>, <em>segment_list</em>, <em>template_output</em>, <em>use_cluster</em>, <em>downsample_factor=1</em>, <em>upsample_threshold=1</em>, <em>upsample_method='pruned_fft'</em>, <em>gpu_callback_method='none'</em>, <em>cluster_function='symmetric'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterControl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterControl" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="pycbc.filter.matchedfilter.MatchedFilterControl.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>low_frequency_cutoff</em>, <em>high_frequency_cutoff</em>, <em>snr_threshold</em>, <em>tlen</em>, <em>delta_f</em>, <em>dtype</em>, <em>segment_list</em>, <em>template_output</em>, <em>use_cluster</em>, <em>downsample_factor=1</em>, <em>upsample_threshold=1</em>, <em>upsample_method='pruned_fft'</em>, <em>gpu_callback_method='none'</em>, <em>cluster_function='symmetric'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterControl.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterControl.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matched filter engine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin the filter calculation. If None, begin at the
first frequency after DC.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop the filter calculation. If None, continue to the
the nyquist frequency.</p>
</div></blockquote>
<p><strong>snr_threshold</strong> : float</p>
<blockquote>
<div><p>The minimum snr to return when filtering</p>
</div></blockquote>
<p><strong>segment_list</strong> : list</p>
<blockquote>
<div><p>List of FrequencySeries that are the Fourier-transformed data segments</p>
</div></blockquote>
<p><strong>template_output</strong> : complex64</p>
<blockquote>
<div><p>Array of memory given as the &#8216;out&#8217; parameter to waveform.FilterBank</p>
</div></blockquote>
<p><strong>use_cluster</strong> : boolean</p>
<blockquote>
<div><p>If true, cluster triggers above threshold using a window; otherwise,
only apply a threshold.</p>
</div></blockquote>
<p><strong>downsample_factor</strong> : {1, int}, optional</p>
<blockquote>
<div><p>The factor by which to reduce the sample rate when doing a heirarchical
matched filter</p>
</div></blockquote>
<p><strong>upsample_threshold</strong> : {1, float}, optional</p>
<blockquote>
<div><p>The fraction of the snr_threshold to trigger on the subsampled filter.</p>
</div></blockquote>
<p><strong>upsample_method</strong> : {pruned_fft, str}</p>
<blockquote>
<div><p>The method to upsample or interpolate the reduced rate filter.</p>
</div></blockquote>
<p><strong>cluster_function</strong> : {symmetric, str}, optional</p>
<blockquote class="last">
<div><p>Which method is used to cluster triggers over time. If &#8216;findchirp&#8217;, a
sliding forward window; if &#8216;symmetric&#8217;, each window&#8217;s peak is compared
to the windows before and after it, and only kept as a trigger if larger
than both.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_and_cluster_fc">
<code class="descname">full_matched_filter_and_cluster_fc</code><span class="sig-paren">(</span><em>segnum</em>, <em>template_norm</em>, <em>window</em>, <em>epoch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterControl.full_matched_filter_and_cluster_fc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_and_cluster_fc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex snr timeseries, normalization of the complex snr,
the correlation vector frequency series, the list of indices of the
triggers, and the snr values at the trigger locations. Returns empty
lists for these for points that are not above the threshold.</p>
<p>Calculated the matched filter, threshold, and cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>segnum</strong> : int</p>
<blockquote>
<div><p>Index into the list of segments at MatchedFilterControl construction
against which to filter.</p>
</div></blockquote>
<p><strong>template_norm</strong> : float</p>
<blockquote>
<div><p>The htilde, template normalization factor.</p>
</div></blockquote>
<p><strong>window</strong> : int</p>
<blockquote>
<div><p>Size of the window over which to cluster triggers, in samples</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote>
<div><p>A time series containing the complex snr.</p>
</div></blockquote>
<p><strong>norm</strong> : float</p>
<blockquote>
<div><p>The normalization of the complex snr.</p>
</div></blockquote>
<p>corrrelation: FrequencySeries</p>
<blockquote>
<div><p>A frequency series containing the correlation vector.</p>
</div></blockquote>
<p><strong>idx</strong> : Array</p>
<blockquote>
<div><p>List of indices of the triggers.</p>
</div></blockquote>
<p><strong>snrv</strong> : Array</p>
<blockquote class="last">
<div><p>The snr values at the trigger locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_and_cluster_symm">
<code class="descname">full_matched_filter_and_cluster_symm</code><span class="sig-paren">(</span><em>segnum</em>, <em>template_norm</em>, <em>window</em>, <em>epoch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterControl.full_matched_filter_and_cluster_symm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_and_cluster_symm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex snr timeseries, normalization of the complex snr,
the correlation vector frequency series, the list of indices of the
triggers, and the snr values at the trigger locations. Returns empty
lists for these for points that are not above the threshold.</p>
<p>Calculated the matched filter, threshold, and cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>segnum</strong> : int</p>
<blockquote>
<div><p>Index into the list of segments at MatchedFilterControl construction
against which to filter.</p>
</div></blockquote>
<p><strong>template_norm</strong> : float</p>
<blockquote>
<div><p>The htilde, template normalization factor.</p>
</div></blockquote>
<p><strong>window</strong> : int</p>
<blockquote>
<div><p>Size of the window over which to cluster triggers, in samples</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote>
<div><p>A time series containing the complex snr.</p>
</div></blockquote>
<p><strong>norm</strong> : float</p>
<blockquote>
<div><p>The normalization of the complex snr.</p>
</div></blockquote>
<p>corrrelation: FrequencySeries</p>
<blockquote>
<div><p>A frequency series containing the correlation vector.</p>
</div></blockquote>
<p><strong>idx</strong> : Array</p>
<blockquote>
<div><p>List of indices of the triggers.</p>
</div></blockquote>
<p><strong>snrv</strong> : Array</p>
<blockquote class="last">
<div><p>The snr values at the trigger locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_thresh_only">
<code class="descname">full_matched_filter_thresh_only</code><span class="sig-paren">(</span><em>segnum</em>, <em>template_norm</em>, <em>window</em>, <em>epoch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterControl.full_matched_filter_thresh_only"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterControl.full_matched_filter_thresh_only" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex snr timeseries, normalization of the complex snr,
the correlation vector frequency series, the list of indices of the
triggers, and the snr values at the trigger locations. Returns empty
lists for these for points that are not above the threshold.</p>
<p>Calculated the matched filter, threshold, and cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>segnum</strong> : int</p>
<blockquote>
<div><p>Index into the list of segments at MatchedFilterControl construction
against which to filter.</p>
</div></blockquote>
<p><strong>template_norm</strong> : float</p>
<blockquote>
<div><p>The htilde, template normalization factor.</p>
</div></blockquote>
<p><strong>window</strong> : int</p>
<blockquote>
<div><p>Size of the window over which to cluster triggers, in samples.
This is IGNORED by this function, and provided only for API compatibility.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote>
<div><p>A time series containing the complex snr.</p>
</div></blockquote>
<p><strong>norm</strong> : float</p>
<blockquote>
<div><p>The normalization of the complex snr.</p>
</div></blockquote>
<p>corrrelation: FrequencySeries</p>
<blockquote>
<div><p>A frequency series containing the correlation vector.</p>
</div></blockquote>
<p><strong>idx</strong> : Array</p>
<blockquote>
<div><p>List of indices of the triggers.</p>
</div></blockquote>
<p><strong>snrv</strong> : Array</p>
<blockquote class="last">
<div><p>The snr values at the trigger locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.MatchedFilterControl.heirarchical_matched_filter_and_cluster">
<code class="descname">heirarchical_matched_filter_and_cluster</code><span class="sig-paren">(</span><em>segnum</em>, <em>template_norm</em>, <em>window</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterControl.heirarchical_matched_filter_and_cluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterControl.heirarchical_matched_filter_and_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the complex snr timeseries, normalization of the complex snr,
the correlation vector frequency series, the list of indices of the
triggers, and the snr values at the trigger locations. Returns empty
lists for these for points that are not above the threshold.</p>
<p>Calculated the matched filter, threshold, and cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>segnum</strong> : int</p>
<blockquote>
<div><p>Index into the list of segments at MatchedFilterControl construction</p>
</div></blockquote>
<p><strong>template_norm</strong> : float</p>
<blockquote>
<div><p>The htilde, template normalization factor.</p>
</div></blockquote>
<p><strong>window</strong> : int</p>
<blockquote>
<div><p>Size of the window over which to cluster triggers, in samples</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote>
<div><p>A time series containing the complex snr at the reduced sample rate.</p>
</div></blockquote>
<p><strong>norm</strong> : float</p>
<blockquote>
<div><p>The normalization of the complex snr.</p>
</div></blockquote>
<p>corrrelation: FrequencySeries</p>
<blockquote>
<div><p>A frequency series containing the correlation vector.</p>
</div></blockquote>
<p><strong>idx</strong> : Array</p>
<blockquote>
<div><p>List of indices of the triggers.</p>
</div></blockquote>
<p><strong>snrv</strong> : Array</p>
<blockquote class="last">
<div><p>The snr values at the trigger locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.filter.matchedfilter.LiveBatchMatchedFilter">
<em class="property">class </em><code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">LiveBatchMatchedFilter</code><span class="sig-paren">(</span><em>templates</em>, <em>snr_threshold</em>, <em>chisq_bins</em>, <em>maxelements=134217728</em>, <em>snr_abort_threshold=None</em>, <em>newsnr_threshold=None</em>, <em>max_triggers_in_batch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#LiveBatchMatchedFilter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.LiveBatchMatchedFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<p>Calculate SNR and signal consistency tests in a batched progression</p>
<dl class="method">
<dt id="pycbc.filter.matchedfilter.LiveBatchMatchedFilter.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>templates</em>, <em>snr_threshold</em>, <em>chisq_bins</em>, <em>maxelements=134217728</em>, <em>snr_abort_threshold=None</em>, <em>newsnr_threshold=None</em>, <em>max_triggers_in_batch=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#LiveBatchMatchedFilter.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a batched matchedfilter instance</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>templates: list of `FrequencySeries`</strong></p>
<blockquote>
<div><p>List of templates from the FilterBank class.</p>
</div></blockquote>
<p><strong>snr_threshold: float</strong></p>
<blockquote>
<div><p>Minimum value to record peaks in the SNR time series.</p>
</div></blockquote>
<p><strong>chisq_bins: str</strong></p>
<blockquote>
<div><p>Str that determines how the number of chisq bins varies as a</p>
</div></blockquote>
<p><strong>function of the template bank parameters.</strong></p>
<p><strong>maxelements: {int, 2**27}</strong></p>
<blockquote>
<div><p>Maximum size of a batched fourier transform.</p>
</div></blockquote>
<p><strong>snr_abort_threshold: {float, None}</strong></p>
<blockquote>
<div><p>If the SNR is above this threshold, do not record any triggers.</p>
</div></blockquote>
<p><strong>newsnr_threshold: {float, None}</strong></p>
<blockquote>
<div><p>Only record triggers that have a re-weighted NewSNR above this</p>
</div></blockquote>
<p><strong>threshold.</strong></p>
<p><strong>max_triggers_in_batch: {int, None}</strong></p>
<blockquote>
<div><p>Record X number of the loudest triggers by newsnr in each mpi</p>
</div></blockquote>
<p><strong>process group. Signal consistency values will also only be calculated</strong></p>
<p class="last"><strong>for these triggers.</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.LiveBatchMatchedFilter.combine_results">
<code class="descname">combine_results</code><span class="sig-paren">(</span><em>results</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#LiveBatchMatchedFilter.combine_results"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.combine_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine results from different batches of filtering</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.LiveBatchMatchedFilter.process_all">
<code class="descname">process_all</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#LiveBatchMatchedFilter.process_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.process_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Process every batch group and return as single result</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.LiveBatchMatchedFilter.process_data">
<code class="descname">process_data</code><span class="sig-paren">(</span><em>data_reader</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#LiveBatchMatchedFilter.process_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.process_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Process the data for all of the templates</p>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.LiveBatchMatchedFilter.set_data">
<code class="descname">set_data</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#LiveBatchMatchedFilter.set_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.LiveBatchMatchedFilter.set_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the data reader object to use</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl">
<em class="property">class </em><code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">MatchedFilterSkyMaxControl</code><span class="sig-paren">(</span><em>low_frequency_cutoff</em>, <em>high_frequency_cutoff</em>, <em>snr_threshold</em>, <em>tlen</em>, <em>delta_f</em>, <em>dtype</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterSkyMaxControl"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/2/library/functions.html#object" title="(in Python v2.7)"><code class="xref py py-class docutils literal"><span class="pre">object</span></code></a></p>
<dl class="method">
<dt id="pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>low_frequency_cutoff</em>, <em>high_frequency_cutoff</em>, <em>snr_threshold</em>, <em>tlen</em>, <em>delta_f</em>, <em>dtype</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterSkyMaxControl.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matched filter engine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>low_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to begin the filter calculation. If None, begin
at the first frequency after DC.</p>
</div></blockquote>
<p><strong>high_frequency_cutoff</strong> : {None, float}, optional</p>
<blockquote>
<div><p>The frequency to stop the filter calculation. If None, continue
to the nyquist frequency.</p>
</div></blockquote>
<p><strong>snr_threshold</strong> : float</p>
<blockquote class="last">
<div><p>The minimum snr to return when filtering</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl.full_matched_filter_and_cluster">
<code class="descname">full_matched_filter_and_cluster</code><span class="sig-paren">(</span><em>hplus</em>, <em>hcross</em>, <em>hplus_norm</em>, <em>hcross_norm</em>, <em>psd</em>, <em>stilde</em>, <em>window</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#MatchedFilterSkyMaxControl.full_matched_filter_and_cluster"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.MatchedFilterSkyMaxControl.full_matched_filter_and_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the complex snr and normalization.</p>
<p>Calculated the matched filter, threshold, and cluster.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>h_quantities</strong> : Various</p>
<blockquote>
<div><p>FILL ME IN</p>
</div></blockquote>
<p><strong>stilde</strong> : FrequencySeries</p>
<blockquote>
<div><p>The strain data to be filtered.</p>
</div></blockquote>
<p><strong>window</strong> : int</p>
<blockquote>
<div><p>The size of the cluster window in samples.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote>
<div><p>A time series containing the complex snr.</p>
</div></blockquote>
<p><strong>norm</strong> : float</p>
<blockquote>
<div><p>The normalization of the complex snr.</p>
</div></blockquote>
<p>correlation: FrequencySeries</p>
<blockquote>
<div><p>A frequency series containing the correlation vector.</p>
</div></blockquote>
<p><strong>idx</strong> : Array</p>
<blockquote>
<div><p>List of indices of the triggers.</p>
</div></blockquote>
<p><strong>snrv</strong> : Array</p>
<blockquote class="last">
<div><p>The snr values at the trigger locations.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.compute_max_snr_over_sky_loc_stat">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">compute_max_snr_over_sky_loc_stat</code><span class="sig-paren">(</span><em>hplus</em>, <em>hcross</em>, <em>hphccorr</em>, <em>hpnorm=None</em>, <em>hcnorm=None</em>, <em>out=None</em>, <em>thresh=0</em>, <em>analyse_slice=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#compute_max_snr_over_sky_loc_stat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.compute_max_snr_over_sky_loc_stat" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the maximized over sky location statistic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>hplus</strong> : TimeSeries</p>
<blockquote>
<div><p>This is the IFFTed complex SNR time series of (h+, data). If not
normalized, supply the normalization factor so this can be done!
It is recommended to normalize this before sending through this
function</p>
</div></blockquote>
<p><strong>hcross</strong> : TimeSeries</p>
<blockquote>
<div><p>This is the IFFTed complex SNR time series of (hx, data). If not
normalized, supply the normalization factor so this can be done!</p>
</div></blockquote>
<p><strong>hphccorr</strong> : float</p>
<blockquote>
<div><p>The real component of the overlap between the two polarizations
Re[(h+, hx)]. Note that the imaginary component does not enter the
detection statistic. This must be normalized and is sign-sensitive.</p>
</div></blockquote>
<p><strong>thresh</strong> : float</p>
<blockquote>
<div><p>Used for optimization. If we do not care about the value of SNR
values below thresh we can calculate a quick statistic that will
always overestimate SNR and then only calculate the proper, more
expensive, statistic at points where the quick SNR is above thresh.</p>
</div></blockquote>
<p><strong>hpsigmasq</strong> : float</p>
<blockquote>
<div><p>The normalization factor (h+, h+). Default = None (=1, already
normalized)</p>
</div></blockquote>
<p><strong>hcsigmasq</strong> : float</p>
<blockquote>
<div><p>The normalization factor (hx, hx). Default = None (=1, already
normalized)</p>
</div></blockquote>
<p><strong>out</strong> : TimeSeries (optional, default=None)</p>
<blockquote>
<div><p>If given, use this array to store the output.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>det_stat</strong> : TimeSeries</p>
<blockquote class="last">
<div><p>The SNR maximized over sky location</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter.compute_followup_snr_series">
<code class="descclassname">pycbc.filter.matchedfilter.</code><code class="descname">compute_followup_snr_series</code><span class="sig-paren">(</span><em>data_reader</em>, <em>htilde</em>, <em>trig_time</em>, <em>duration=0.095</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter.html#compute_followup_snr_series"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter.compute_followup_snr_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a StrainBuffer, a template frequency series and a trigger time,
compute a portion of the SNR time series centered on the trigger for its
sky localization and followup.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data_reader</strong> : StrainBuffer</p>
<blockquote>
<div><p>The StrainBuffer object to read strain data from.</p>
</div></blockquote>
<p><strong>htilde</strong> : FrequencySeries</p>
<blockquote>
<div><p>The frequency series containing the template waveform.</p>
</div></blockquote>
<p><strong>trig_time</strong> : {float, lal.LIGOTimeGPS}</p>
<blockquote>
<div><p>The trigger time.</p>
</div></blockquote>
<p><strong>duration</strong> : float (optional)</p>
<blockquote>
<div><p>Duration of the computed SNR series in seconds. If omitted, it defaults
to twice the Earth light travel time plus 10 ms of timing uncertainty.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>snr</strong> : TimeSeries</p>
<blockquote>
<div><p>The portion of SNR around the trigger.</p>
</div></blockquote>
<p><strong>psd</strong> : FrequencySeries</p>
<blockquote class="last">
<div><p>The noise PSD corresponding to the trigger time.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.filter.matchedfilter_cpu">
<span id="pycbc-filter-matchedfilter-cpu-module"></span><h2>pycbc.filter.matchedfilter_cpu module<a class="headerlink" href="#module-pycbc.filter.matchedfilter_cpu" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pycbc.filter.matchedfilter_cpu.CPUCorrelator">
<em class="property">class </em><code class="descclassname">pycbc.filter.matchedfilter_cpu.</code><code class="descname">CPUCorrelator</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter_cpu.html#CPUCorrelator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.CPUCorrelator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">pycbc.filter.matchedfilter._BaseCorrelator</span></code></p>
<dl class="method">
<dt id="pycbc.filter.matchedfilter_cpu.CPUCorrelator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter_cpu.html#CPUCorrelator.__init__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.CPUCorrelator.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pycbc.filter.matchedfilter_cpu.CPUCorrelator.correlate">
<code class="descname">correlate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter_cpu.html#CPUCorrelator.correlate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.CPUCorrelator.correlate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter_cpu.batch_correlate_execute">
<code class="descclassname">pycbc.filter.matchedfilter_cpu.</code><code class="descname">batch_correlate_execute</code><span class="sig-paren">(</span><em>self</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter_cpu.html#batch_correlate_execute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.batch_correlate_execute" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter_cpu.correlate">
<code class="descclassname">pycbc.filter.matchedfilter_cpu.</code><code class="descname">correlate</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.correlate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter_cpu.correlate_batch_inline">
<code class="descclassname">pycbc.filter.matchedfilter_cpu.</code><code class="descname">correlate_batch_inline</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter_cpu.html#correlate_batch_inline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.correlate_batch_inline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter_cpu.correlate_inline">
<code class="descclassname">pycbc.filter.matchedfilter_cpu.</code><code class="descname">correlate_inline</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter_cpu.html#correlate_inline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.correlate_inline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pycbc.filter.matchedfilter_cpu.correlate_numpy">
<code class="descclassname">pycbc.filter.matchedfilter_cpu.</code><code class="descname">correlate_numpy</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/matchedfilter_cpu.html#correlate_numpy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.matchedfilter_cpu.correlate_numpy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pycbc.filter.resample">
<span id="pycbc-filter-resample-module"></span><h2>pycbc.filter.resample module<a class="headerlink" href="#module-pycbc.filter.resample" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pycbc.filter.resample.resample_to_delta_t">
<code class="descclassname">pycbc.filter.resample.</code><code class="descname">resample_to_delta_t</code><span class="sig-paren">(</span><em>timeseries</em>, <em>delta_t</em>, <em>method='butterworth'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/resample.html#resample_to_delta_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.resample.resample_to_delta_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Resmple the time_series to delta_t</p>
<p>Resamples the TimeSeries instance time_series to the given time step, 
delta_t. Only powers of two and real valued time series are supported 
at this time. Additional restrictions may apply to particular filter
methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>time_series: TimeSeries</strong></p>
<blockquote>
<div><p>The time series to be resampled</p>
</div></blockquote>
<p><strong>delta_t: float</strong></p>
<blockquote>
<div><p>The desired time step</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Time Series: TimeSeries</p>
<blockquote>
<div><p>A TimeSeries that has been resampled to delta_t.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError:</strong></p>
<blockquote>
<div><p>time_series is not an instance of TimeSeries.</p>
</div></blockquote>
<p><strong>TypeError:</strong></p>
<blockquote class="last">
<div><p>time_series is not real valued</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h_plus_sampled</span> <span class="o">=</span> <span class="n">resample_to_delta_t</span><span class="p">(</span><span class="n">h_plus</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">/</span><span class="mi">2048</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.resample.highpass">
<code class="descclassname">pycbc.filter.resample.</code><code class="descname">highpass</code><span class="sig-paren">(</span><em>timeseries</em>, <em>frequency</em>, <em>filter_order=8</em>, <em>attenuation=0.1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/resample.html#highpass"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.resample.highpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new timeseries that is highpassed.</p>
<p>Return a new time series that is highpassed above the <cite>frequency</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Time Series: TimeSeries</strong></p>
<blockquote>
<div><p>The time series to be high-passed.</p>
</div></blockquote>
<p><strong>frequency: float</strong></p>
<blockquote>
<div><p>The frequency below which is suppressed.</p>
</div></blockquote>
<p><strong>filter_order: {8, int}, optional</strong></p>
<blockquote>
<div><p>The order of the filter to use when high-passing the time series.</p>
</div></blockquote>
<p><strong>attenuation: {0.1, float}, optional</strong></p>
<blockquote>
<div><p>The attenuation of the filter.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Time Series: TimeSeries</p>
<blockquote>
<div><p>A  new TimeSeries that has been high-passed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first"><strong>TypeError:</strong></p>
<blockquote>
<div><p>time_series is not an instance of TimeSeries.</p>
</div></blockquote>
<p><strong>TypeError:</strong></p>
<blockquote class="last">
<div><p>time_series is not real valued</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.resample.interpolate_complex_frequency">
<code class="descclassname">pycbc.filter.resample.</code><code class="descname">interpolate_complex_frequency</code><span class="sig-paren">(</span><em>series</em>, <em>delta_f</em>, <em>zeros_offset=0</em>, <em>side='right'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/resample.html#interpolate_complex_frequency"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.resample.interpolate_complex_frequency" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate complex frequency series to desired delta_f.</p>
<p>Return a new complex frequency series that has been interpolated to the
desired delta_f.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>series</strong> : FrequencySeries</p>
<blockquote>
<div><p>Frequency series to be interpolated.</p>
</div></blockquote>
<p><strong>delta_f</strong> : float</p>
<blockquote>
<div><p>The desired delta_f of the output</p>
</div></blockquote>
<p><strong>zeros_offset</strong> : optional, {0, int}</p>
<blockquote>
<div><p>Number of sample to delay the start of the zero padding</p>
</div></blockquote>
<p><strong>side</strong> : optional, {&#8216;right&#8217;, str}</p>
<blockquote>
<div><p>The side of the vector to zero pad</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>interpolated series</strong> : FrequencySeries</p>
<blockquote class="last">
<div><p>A new FrequencySeries that has been interpolated.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.resample.highpass_fir">
<code class="descclassname">pycbc.filter.resample.</code><code class="descname">highpass_fir</code><span class="sig-paren">(</span><em>timeseries</em>, <em>frequency</em>, <em>order</em>, <em>beta=5.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/resample.html#highpass_fir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.resample.highpass_fir" title="Permalink to this definition">¶</a></dt>
<dd><p>Highpass filter the time series using an FIR filtered generated from 
the ideal response passed through a kaiser window (beta = 5.0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Time Series: TimeSeries</strong></p>
<blockquote>
<div><p>The time series to be high-passed.</p>
</div></blockquote>
<p><strong>frequency: float</strong></p>
<blockquote>
<div><p>The frequency below which is suppressed.</p>
</div></blockquote>
<p><strong>order: int</strong></p>
<blockquote>
<div><p>Number of corrupted samples on each side of the time series</p>
</div></blockquote>
<p><strong>beta: float</strong></p>
<blockquote class="last">
<div><p>Beta parameter of the kaiser window that sets the side lobe attenuation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pycbc.filter.resample.lowpass_fir">
<code class="descclassname">pycbc.filter.resample.</code><code class="descname">lowpass_fir</code><span class="sig-paren">(</span><em>timeseries</em>, <em>frequency</em>, <em>order</em>, <em>beta=5.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/resample.html#lowpass_fir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.resample.lowpass_fir" title="Permalink to this definition">¶</a></dt>
<dd><p>Lowpass filter the time series using an FIR filtered generated from 
the ideal response passed through a kaiser window (beta = 5.0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>Time Series: TimeSeries</strong></p>
<blockquote>
<div><p>The time series to be low-passed.</p>
</div></blockquote>
<p><strong>frequency: float</strong></p>
<blockquote>
<div><p>The frequency below which is suppressed.</p>
</div></blockquote>
<p><strong>order: int</strong></p>
<blockquote>
<div><p>Number of corrupted samples on each side of the time series</p>
</div></blockquote>
<p><strong>beta: float</strong></p>
<blockquote class="last">
<div><p>Beta parameter of the kaiser window that sets the side lobe attenuation.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-pycbc.filter.simd_correlate">
<span id="pycbc-filter-simd-correlate-module"></span><h2>pycbc.filter.simd_correlate module<a class="headerlink" href="#module-pycbc.filter.simd_correlate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pycbc.filter.simd_correlate.correlate_parallel">
<code class="descclassname">pycbc.filter.simd_correlate.</code><code class="descname">correlate_parallel</code><span class="sig-paren">(</span><em>ht</em>, <em>st</em>, <em>qt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/simd_correlate.html#correlate_parallel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.simd_correlate.correlate_parallel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pycbc.filter.simd_correlate.correlate_simd">
<code class="descclassname">pycbc.filter.simd_correlate.</code><code class="descname">correlate_simd</code><span class="sig-paren">(</span><em>ht</em>, <em>st</em>, <em>qt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/simd_correlate.html#correlate_simd"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.simd_correlate.correlate_simd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pycbc.filter.zpk">
<span id="pycbc-filter-zpk-module"></span><h2>pycbc.filter.zpk module<a class="headerlink" href="#module-pycbc.filter.zpk" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pycbc.filter.zpk.filter_zpk">
<code class="descclassname">pycbc.filter.zpk.</code><code class="descname">filter_zpk</code><span class="sig-paren">(</span><em>timeseries</em>, <em>z</em>, <em>p</em>, <em>k</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/pycbc/filter/zpk.html#filter_zpk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#pycbc.filter.zpk.filter_zpk" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new timeseries that was filtered with a zero-pole-gain filter.
The transfer function in the s-domain looks like:
.. math::
frac{H(s) = (s - s_1) * (s - s_3) * ... * (s - s_n)}{(s - s_2) * (s - s_4) * ... * (s - s_m)}, m &gt;= n</p>
<p>The zeroes, and poles entered in Hz are converted to angular frequency,
along the imaginary axis in the s-domain s=i*omega.  Then the zeroes, and
poles are bilinearly transformed via:
.. math::
z(s) = frac{(1 + s*T/2)}{(1 - s*T/2)}</p>
<p>Where z is the z-domain value, s is the s-domain value, and T is the
sampling period.  After the poles and zeroes have been bilinearly
transformed, then the second-order sections are found and filter the data
using scipy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>timeseries: TimeSeries</strong></p>
<blockquote>
<div><p>The TimeSeries instance to be filtered.</p>
</div></blockquote>
<p><strong>z: array</strong></p>
<blockquote>
<div><p>Array of zeros to include in zero-pole-gain filter design.
In units of Hz.</p>
</div></blockquote>
<p><strong>p: array</strong></p>
<blockquote>
<div><p>Array of poles to include in zero-pole-gain filter design.
In units of Hz.</p>
</div></blockquote>
<p><strong>k: float</strong></p>
<blockquote>
<div><p>Gain to include in zero-pole-gain filter design. This gain is a
constant multiplied to the transfer function.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Time Series: TimeSeries</p>
<blockquote class="last">
<div><p>A  new TimeSeries that has been filtered.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>To apply a 5 zeroes at 100Hz, 5 poles at 1Hz, and a gain of 1e-10 filter
to a TimeSeries instance, do:
&gt;&gt;&gt; filtered_data = zpk_filter(timeseries, [100]*5, [1]*5, 1e-10)</p>
</dd></dl>

</div>
<div class="section" id="module-pycbc.filter">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pycbc.filter" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pycbc.inference.html" class="btn btn-neutral float-right" title="pycbc.inference package" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pycbc.fft.html" class="btn btn-neutral" title="pycbc.fft package" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2014, Alexander Nitz.
      Last updated on Apr 03, 2017.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'be65a5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>